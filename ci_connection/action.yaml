# Copyright 2024 Google LLC

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     https://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
name: "Wait For Connection"
description: 'Action to wait for connection from user (conditionally)'
inputs:
  halt-dispatch-input:
    description: 'Should the action wait for user connection from workflow_dispatch?'
    required: false
    default: "no"
runs:
  using: "composite"
  steps:
  # First try to set up waiting with Python, as it has some QoL features, like mirroring the `env` state, etc.
  - name: Wait for connection (conditionally)
    id: primary
    shell: bash
    env:
      PYTHONUNBUFFERED: 1
      HALT_DISPATCH_INPUT: ${{ inputs.halt-dispatch-input }}
    # The calling workflow shouldn't fail in case this step does
    continue-on-error: true
    run: |
      # Pick an existing Python alias, if any exists
      python_bin=$(which python3 2>/dev/null || which python)
      # Attempt to run; capture exit code of script, or non-zero if python missing/fails
      # [[ -n "$python_bin" ]] && "$python_bin" "$GITHUB_ACTION_PATH/wait_for_connection.py"
      # exit_code="$?"
      # echo "exit_code=${exit_code}" >> "$GITHUB_OUTPUT"
      echo "Finished the steppy-step, moving on..."

  # If Python fails, or isn't available, fall back to using Bash for a simpler keep-alive loop
  - name: Wait for connection (shell-based fallback in case Python is not available, or fails)
    if: ${{ steps.primary.outputs.exit_code != '0' }}
    continue-on-error: true
    shell: bash
    run: bash "$GITHUB_ACTION_PATH/wait_for_connection_fallback.sh"
